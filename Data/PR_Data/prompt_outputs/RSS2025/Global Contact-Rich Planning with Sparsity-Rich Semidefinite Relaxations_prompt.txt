=== PDFÊñá‰ª∂: Global Contact-Rich Planning with Sparsity-Rich Semidefinite Relaxations.pdf ===
=== Êó∂Èó¥: 2025-07-21 13:13:57.111251 ===

ËØ∑‰ªé‰ª•‰∏ãËÆ∫ÊñáÂÜÖÂÆπ‰∏≠ÔºåÊåâÂ¶Ç‰∏ãJSONÊ†ºÂºè‰∏•Ê†ºËæìÂá∫ÔºàÊâÄÊúâÂ≠óÊÆµÈÉΩË¶ÅÊúâÔºåÂÖ≥ÈîÆËØçÂ≠óÊÆµËØ∑Âè™ËæìÂá∫‰∏Ä‰∏™‰∏≠ÊñáÂÖ≥ÈîÆËØçÔºåË¶Å‰∏≠ÊñáÂÖ≥ÈîÆËØçÔºâÔºö
{
  "ËÆ∫ÊñáÊ†áÈ¢ò": "",
  "Á†îÁ©∂‰∏ªÈ¢òÂÖ≥ÈîÆËØç": "",
  "Â∫îÁî®Âú∫ÊôØÂÖ≥ÈîÆËØç": "",
  "‰∏ªË¶ÅÊñπÊ≥ïÂÖ≥ÈîÆËØç": "",
  "ÂàõÊñ∞ÁÇπÂÖ≥ÈîÆËØç": "",
  "‰∏ªË¶ÅÁªìËÆ∫ÂÖ≥ÈîÆËØç": ""
}
ÂÜÖÂÆπÔºöGlobal Contact-Rich Planning with
Sparsity-Rich Semidefinite Relaxations
Shucheng Kang‚àó1, Guorui Liu‚àó2, Heng Yang1
1School of Engineering and Applied Sciences, Harvard University
2School of Mathematical Sciences, University of Science and Technology of China
‚àóEqual contribution
Markov Sparsity 
(Planning Horizon)
Specific Sparsity
(a)
(b)
(c)
Fig. 1: Contact-rich planning is sparsity-rich. (a) Sparsity graph of planar hand manipulation showing two types of sparsity. (b)
Sparsity enables high-order and tight, yet small-scale, semidefinite programming (SDP) relaxations solvable by off-the-shelf
SDP solvers, computing certified near globally optimal trajectories for a suite of simulated problems. (c) Real-world validation
on push-T. Planning powered by global optimization succeeds the task even under severe model mismatches and disturbances
(from top to bottom: clean T; T tied up by a cable; T on top of a cluttered table; and T inside a ‚Äúsliding‚Äù box).
Abstract‚ÄîWe show that contact-rich motion planning is also
sparsity-rich when viewed as polynomial optimization (POP). We
can exploit not only the correlative and term sparsity patterns
that are general to all POPs, but also specialized sparsity patterns
from the robot kinematic structure and the separability of contact
modes. Such sparsity enables the design of high-order but sparse
semidefinite programming (SDPs) relaxations‚Äîbuilding upon
Lasserre‚Äôs moment and sums of squares hierarchy‚Äîthat (i) can
be solved in seconds by off-the-shelf SDP solvers, and (ii) compute
near globally optimal solutions to the nonconvex contact-rich
planning problems with small certified suboptimality. Through
extensive experiments both in simulation (Push Bot, Push Box,
Push Box with Obstacles, and Planar Hand) and real world
(Push T), we demonstrate the power of using convex SDP
relaxations to generate global contact-rich motion plans. As
a contribution of independent interest, we release the Sparse
Polynomial Optimization Toolbox (SPOT)‚Äîimplemented in C++
with interfaces to both Python and Matlab‚Äîthat automates
sparsity exploitation for robotics and beyond.
I. INTRODUCTION
Contact-rich planning plays a fundamental role in robotics
tasks ranging from manipulation to locomotion [29, 9, 14].
At the heart of such planning problems lie two interrelated
challenges: (a) Contact mode selection: determining when
and where to establish or break contact is critical, yet the
number of possible contact sequences grows exponentially
with the number of contact modes and the planning horizon;
(b) Nonlinear dynamics and nonconvex geometric constraints:
the planned trajectory must satisfy the system‚Äôs nonlinear
dynamics and geometric constraints such as avoiding self and
obstacle collisions. Together, these challenges exacerbate the
problem‚Äôs nonconvexity and computational complexity.
Problem statement. Let N represent the planning hori-
zon with [N] := {1, 2, . . . , N}. Define the state trajectory
{xk}N
k=0 ‚äÇRnx and the control input trajectory {uk}N‚àí1
k=0 ‚äÇ
Rnu. For contact-rich planning problems, we introduce ‚Äúcon-
tact variables‚Äù {Œªk}N‚àí1
k=0
‚äÇRnŒª, which can be interpreted
either as a set of binary contact modes or as continuous contact
forces (see examples in ¬ßIV). With these definitions, we focus
on the following general contact-rich planning problem
min
{xk}N
k=0,{uk}N‚àí1
k=0
{Œªk}N‚àí1
k=0
‚ÑìN(xN) +
N‚àí1
X
k=0
‚Ñìk(xk, uk, Œªk)
(1a)
subject to
x0 = xinit
(1b)
Fk(xk‚àí1, uk‚àí1, Œªk‚àí1, xk) = 0, k ‚àà[N] (1c)
(uk‚àí1, Œªk‚àí1, xk) ‚ààCk, k ‚àà[N]
(1d)
where ‚Ñìk, k = 0, . . . , N represents instantaneous loss and
terminal loss functions. Fk represents the discretized system
dynamics obtained from differential algebraic equations and
multiple shooting, possibly involving explicit or implicit con-
tact mode switching. Ck imposes various types of constraints
on uk‚àí1, Œªk‚àí1, xk, including (a) control limits; (b) geometric
constraints such as collision avoidance; (c) complementarity
constraints related to contact. A well-known special case
of (1) occurs when the dynamics are linear when fixing
Œªk‚Äôs. In such case, (1) can be modeled either as mixed-
integer linear/quadratic programming [10, 28] or as linear
complementarity problems [3, 51].
In this paper, we do not assume linearity or convexity but
assume (a) ‚Ñìk and Fk are polynomial functions; (b) Ck is ba-
sic semi-algebraic (i.e., described by polynomial constraints).
Thus, (1) becomes a polynomial optimization problem (POP).
Formulating robotics problems as polynomial optimization is
now well established in the literature [23, 47, 16, 39], because
3D rotations and rigid body dynamics expressed in maximal
coordinates  admit natural polynomial representations.
Previous methods. We briefly review five different methods
for solving the contact-rich planning (1). (a) Hybrid MPC:
These methods alternate between contact sequence generation
using discrete search [7, 45, 8, 30] and continuous-state
planning with a fixed sequence. (b) Mixed-integer program-
ming: Contact modes are modeled as binary variables, leading
to mixed-integer convex programming (with linear dynam-
ics) [10, 28] or mixed-integer nonconvex programming (with
nonlinear dynamics) . These methods scale poorly with the
planning horizon, as the worst-case computational complexity
grows exponentially with the number of binary variables. (c)
Dynamics smoothing: This approach approximates nonsmooth
complementarity constraints with smooth surrogate functions,
simplifying the problem into a smooth nonlinear programming
formulation suitable for local solvers [6, 38, 31, 37]. Convex
smoothing methods  also exist, at the cost of locally
linearizing the dynamics. (d) Contact-implicit methods: These
mainstream methods encode contact modes implicitly through
contact forces and complementarity constraints. Numerous
local solvers are based on this framework [2, 52, 35, 27,
49, 22]. However, it is well known that contact-implicit
planning problems fail the common constraint qualifications
that are crucial for the convergence of numerical solvers. (e)
Graph of convex sets (GCS): As a recently proposed powerful
planning framework that explicitly models both discrete and
continuous actions, GCS has been extended to contact-rich
tasks [13, 48, 32]. These methods can be viewed as an
extension of mixed-integer nonconvex optimization with two-
level convex relaxations where level one is a semidefinite
relaxation and level two involves inequality multiplication.
However, in contact-rich motion planning, achieving both tight
relaxations and fast solve times remains challenging, and the
current GCS framework has yet to fully integrate nonlinear
dynamics with geometric constraints.
Is it possible to solve the contact-rich planning
problem (1) to (near) global optimality efficiently?
‚ÄúSparse‚Äù Moment-SOS hierarchy. Modeling contact-
implicit planning as polynomial optimization (POP) in (1)
brings both opportunities and challenges.
‚Ä¢ Opportunities. Lasserre‚Äôs hierarchy of moment and
sums-of-squares (SOS) relaxations  provides a prin-
cipled and powerful machinery for global optimization
of POPs through convex relaxations. Particularly, the
Moment-SOS hierarchy generates a series of convex
semidefinite programs (SDPs) with growing sizes whose
optimal values provide nondecreasing lower bounds that
asymptotically converge to the global minimum of (1).
Combined with a feasible (or locally optimal) solution
of (1) that provides an upper bound to the global
minimum, one can compute increasingly tight (small)
(sub)optimality certificates by measuring the relative gap
between the lower bound and the upper bound. To en-
hance scalability of the hierarchy, ‚Äúsparse‚Äù Moment-SOS
hierarchy has been proposed to exploit sparsity in the
POPs, including correlative sparsity [21, 15] and term
sparsity [43, 26] (see more details in ¬ßII). Notably, the
Julia package TSSOS  supports automatic sparsity
exploitation as long as the user provides a POP formu-
lation. The recent work  in robotics applied TSSOS
to several motion planning problems and demonstrated
that sparse relaxations can deliver small suboptimality
gaps. Furthermore,  has shown that all trajectory opti-
mization problems exhibit a generic chain-like correlative
sparsity pattern and designed a GPU-based ADMM SDP
solver that achieves significant speedup than off-the-shelf
SDP solvers. Can we directly apply sparse Moment-SOS
relaxations to the contact-implicit planning problem (1)?
‚Ä¢ Challenges. The answer is unfortunately NO, due to three
challenges. First, multiple contact modes will make the
chain-like correlative sparsity pattern introduced in 
too large to be solved efficiently. Second, TSSOS allows
exploiting more flexible sparsity patterns but its automatic
sparsity exploitation operates like a black box‚Äîit does
not visualize the sparsity patterns being exploited and it is
unclear whether robotics-specific domain knowledge can
lead to customized sparsity. Third, as reported in , the
suboptimality gaps when using TSSOS for many smooth
planning problems are already large (above 20%), not to
mention the extra nonsmoothness and combinatorial com-
plexity brought by contact-implicit planning. As shown
in , TSSOS can fail to extract feasible solutions for
certain difficult instances of (1).
Contributions. In this paper, we tackle the aforementioned
challenges and show that it is indeed possible to solve many
instances of the contact-implicit planning problem (1) to near
global optimality. The key strategy is to build ‚Äúsparsity-rich‚Äù
semidefinite relaxations from the ground up, for robotics.
We summarize our contributions as follows.
(I) White-box sparsity exploitation. We provide a tutorial-
style review of the fundamental mathematical concepts
underpinning correlative and term sparsity for POPs,
and further ground our discussion in a concrete contact-
implicit planning problem. We build a new C++ Sparse
Polynomial Optimization Toolbox (SPOT), interfacing
both Matlab and Python, that (a) is faster than TSSOS,
(b) offers richer relaxation options, and (c) visualizes the
automatically discovered sparsity patterns (see Fig. 1).
(II) Robotics-specific sparsity. Beyond automatic exploita-
tion of the generic correlative and term sparsity, we show
that it is possible and crucial to exploit robotics-specific
sparsity patterns. Particularly, we investigate sparsities de-
rived from robot kinematic chains and separable contact
modes, and demonstrate that robotics-specific sparsity
patterns achieve both tighter lower bounds and reduced
computation times compared to automatically generated
ones in large-scale problems such as Planar Hand.
(III) Robust minimizer extraction. An important but often
overlooked problem in SDP relaxations is how to extract
good solutions to the nonconvex optimization from op-
timal SDP solutions, especially when the relaxation is
not tight (i.e., the suboptimality gap is large). Inspired
by the recent advances in Gelfand-Naimark-Segal (GNS)
construction , we develop a new minimizer extraction
routine for sparse Moment-SOS relaxations that demon-
strates superior robustness over naive extraction methods
previously implemented in [16, 25].
(IV) Extensive case studies. We test our sparse semidefinite
relaxations on five contact-rich planning problems: Push
Bot, Push Box, Push T, Push Box with Obstacles, and
Planar Hand. Of independent interests, some of our poly-
nomial modeling techniques also appear to be new in the
planning literature. Thanks to rich sparsity, the generated
small-to-medium scale SDP relaxations can be solved in
seconds while achieving decent tightness and certified
global optimality. Furthermore, we showcase robust push-
T performance of our SDP relaxations using a real-world
robotic manipulator. In fact, with global optimization,
model predictive control is so robust that it succeeds
the task even under severe environment disturbances that
effectively make the ‚Äúmodel wrong‚Äù (see Fig. 1).
Paper organization. We present correlative and term spar-
sity in ¬ßII, robotics-specific sparsity in ¬ßIII. We give numerical
and real-world experiments in ¬ßIV, and conclude in ¬ßV.
Notations. Let x = (x1, . . . , xn) be a tuple of variables and
R[x] = R[x1, . . . , xn] be the set of polynomials in x with real
coefficients. A monomial is defined as xŒ± = xŒ±1
1 xŒ±2
2 ¬∑ ¬∑ ¬∑ xŒ±n
n .
A polynomial in x can be written as f(x) = P
Œ±‚ààNn fŒ±xŒ±
with coefficients fŒ± ‚ààR. We denote the set of all polynomials
with degree less than or equal to d as Rd[x]. The support
of f is defined by supp(f) = {Œ± ‚ààNn | fŒ± Ã∏= 0}, i.e., the
set of exponents with nonzero coefficients. The set of all
variables contained in f is defined by var(f). Let xNn
d be
the standard monomial basis, abbreviated as [x]d. Given an
index set I ‚äÜ[n], let x(I) = (xi, i ‚ààI) and [x(I)]d
denote the standard monomial basis of the subspace spanned
by the variables xi, i ‚ààI. An undirected graph G(V, E)
consists of a vertex set V = v1, v2, . . . , vn and an edge set
E ‚äÜ{(vi, vj) | vi, vj ‚ààV, vi Ã∏= vj}. Let Sn denote the space
of n√ón symmetric matrices, and Sn
+ denote the cone of n√ón
symmetric positive semidefinite (PSD) matrices.
II. CORRELATIVE AND TERM SPARSITY
In this section, we review a systematic mechanism to relax a
general (nonconvex) polynomial optimization problem (POP)
as a (convex) semidefinite program (SDP) while exploiting two
levels of sparsity: (a) variable level‚Äîcorrelative sparsity (CS);
and (b) term level‚Äîterm sparsity (TS). Formally, we consider
the following POP
œÅ‚ãÜ= min
x‚ààRn

f(x)

g1(x) ‚â•0, . . . , gmineq(x) ‚â•0,
h1(x) = 0, . . . , hmeq(x) = 0

(2)
where the objective function f and the constraints gi, hi are
all real polynomials. To ground our discussion in a concrete
robotics example, let us consider the following simple contact-
rich motion planning problem.
Example 1 (Double Integrator with Soft Wall). As shown in
Fig. 2, consider a point mass m driven by a control force u
that can bounce between two soft walls with spring coefficients
k1 and k2. Denote the system state as (x, v) (x: position, v:
velocity), the control input as u, and the two wall‚Äôs forces
as (Œª1, Œª2), we consider the following trajectory optimization
(optimal control) problem
min
N‚àí1
X
k=0
u2
k + x2
k+1 + v2
k+1
(3a)
s.t.
xk+1 ‚àíxk = ‚àÜt ¬∑ vk
(3b)
vk+1 ‚àívk = ‚àÜt
m ¬∑ (uk + Œª1,k ‚àíŒª2,k)
(3c)
u2
max ‚àíu2
k ‚â•0
(3d)
0 ‚â§Œª1,k ‚ä•Œª1,k
k1
+ d1 + xk ‚â•0
(3e)
0 ‚â§Œª2,k ‚ä•Œª2,k
k2
+ d2 ‚àíxk ‚â•0
(3f)
x0 = xinit
and
v0 = vinit
(3g)
where ‚àÜt represents the time discretization, (3a) formulates
a quadratic regulation loss function around x = 0, v = 0,
(3b)-(3c) represent system dynamics, (3d) enforces control sat-
uration, (3e)-(3f) specify the soft complementarity constraints
between position and contact forces, and (3g) provides the
initial condition. Œª1,k denotes the contact force at step k.
Outline. We begin by introducing the fundamentals of
chordal graphs, a key mathematical tool for analyzing sparsity
patterns (¬ßII-A). Next, we review correlative sparsity (CS)
(¬ßII-B) and term sparsity (TS) (¬ßII-C) separately. Finally,
we introduce our high-performance C++ sparse polynomial
optimization toolbox, SPOT (¬ßII-D).
d1
d2
x
k1
k2
Œª1
Œª1
Fig. 2: Double integrator with soft wall.
A. Chordal Graph
Definition 2 (Chordal graph). A graph G = (V, E) is chordal
if every cycle of four or more vertices has a chord‚Äîan edge
connecting two non-adjacent vertices in the cycle.
For a quick example, the graph in Fig. 3(a) is not chordal
but the graph in Fig. 3(b) is. Apparently, one can change a
non-chordal graph to chordal by adding edges. This is the
notion of a chordal extension.
Chordal extension. A graph G‚Ä≤(V ‚Ä≤, E‚Ä≤) is called a chordal
extension of graph G(V, E) if (a) G‚Ä≤ is chordal, and (b)
V ‚Ä≤ = V
and E
‚äÜE‚Ä≤. The ideal objective of chordal
extension is to add the minimum number of edges to G to
make G‚Ä≤ chordal. However, it is known that finding such a
minimal chordal extension is NP-complete . A common
heuristic for approximating the minimal chordal extension is
the minimal degree (MD) chordal extension . An alter-
native heuristic is to select vertices based on the number of
additional edges (MF) required to maintain chordality . We
summarize the MD chordal extension method in Algorithm 1
and MF chordal extension in Algorithm 2 in Appendix A. In
our SPOT package, we implement both algorithms.
Maximal cliques. Once the chordal extension is con-
structed, the next step is to identify the maximal cliques.
Definition 3 (Clique). A clique in a graph G(V, E) is a subset
of vertices C ‚äÜV where every pair of vertices is connected
by an edge. A clique is maximal if it is not properly contained
within any other clique in G.
The nice consequence of the chordal extension is that
the maximal cliques of a chordal graph can be enumerated
efficiently in linear time in terms of the number of nodes and
edges [11, 4, 12]. Identifying all maximal cliques in a chordal
graph plays a fundamental role in exploiting sparsity patterns.
(a)
(b)
(c)
Fig. 3: An example of chordal extension and maximal cliques.
Example 4 (Chordal Extension and Maximal Cliques). Con-
sider the graph in Fig. 3(a) that is non-chordal. The MD
chordal extension Algorithm 1 adds two edges (B, D), (B, F),
leading to the chordal graph in Fig. 3(b). The maximal cliques
of the resulting chordal graph are {A, B, D}, {B, D, E},
{B, E, F}, and {B, C, F}, as shown in Fig. 3(c).
With the notion of a chordal graph and maximal cliques, it
is natural to use such a graph-theoretic tool to exploit sparsity.
B. Correlative Sparsity
As mentioned before, correlative sparsity (CS) seeks to
exploit sparsity in the ‚Äúvariable‚Äù level. Roughly speaking,
the intuition is that we can construct a graph that represents
the connectivity in the POP (2), perform a chordal extension
to that graph, and find its maximal cliques to group the
(potentially very large number of) POP variables into many
groups where each group only contains a few variables .
CS graph construction. The graph Gcsp(V, E) is the cor-
relative sparsity pattern (CSP) graph of a POP with variables
x ‚ààRn if V = [n] and (i, j) ‚ààE if at least one of the
following three conditions holds:
1) ‚àÉŒ± ‚ààsupp(f), s.t. Œ±i, Œ±j > 0,
2) ‚àÉk ‚àà[mineq], s.t. xi, xj ‚ààvar(gk),
3) ‚àÉk ‚àà[meq], s.t. xi, xj ‚ààvar(hk).
In words, the nodes of the CSP graph represent variables
of the POP, and a pair of nodes are connected if and only if
they simultaneously appear in the objective or the constraints.
Chordal extension and grouping. With the MD chordal
extension Algorithm 1 (or the MF chordal extension Algo-
rithm 2), we compute the chordal extension of Gcsp‚Äî denoted
(Gcsp)‚Ä≤‚Äîand its maximal cliques {Il}p
l=1, where each clique
Il contains a set of nodes (variables). We then partition the
constraint polynomials g1, . . . , gmineq and h1, . . . , hmeq into
groups {gj | j ‚ààGl} and {hj | j ‚ààHl}, where Gl and Hl,
l ‚àà[p] index the inequality and equality constraints involving
the variables in Il, respectively. Formally, this is
1) ‚àÄj ‚ààGl, var(gj) ‚äÜIl,
2) ‚àÄj ‚ààHl, var(hj) ‚äÜIl.
We make this concrete by recalling our robotics Example 1.
Example 5 (CSP Graph of Example 1). Fig. 4 shows the
CSP graph of Example 1. It is already a chordal graph with-
out chordal extension. Two maximal cliques are highlighted:
{x0, v0, Œª1,0, Œª2,0} and {x0, x1, v0}. There is an edge between
x0 and v0 since x1 ‚àíx0 = ‚àÜt ¬∑ v0 shows up in (3b).
After grouping the variables into cliques {Il}p
l=1 and the
polynomial constraints into subsets Hl, Gl, we can design
Fig. 4: CSP graph of the toy Example 1. Red circle: maxi-
mal clique {x0, v0, Œª1,0, Œª2,0}. Orange circle: maximal clique
{x0, x1, v0}. Only variables in the first and last planning steps
are shown for simplicity.
a hierarchy of ‚Äúsparse‚Äù moment and sums-of-squares (SOS)
relaxations to globally optimize the POP (2).
Before we present the sparse Moment-SOS hierarchy, it is
useful to understand the ‚Äúdense‚Äù Moment-SOS hierarchy.
Dense Moment-SOS relaxations. Recall the POP (2). Let
y = (yŒ±)Œ± be a sequence of real numbers indexed by the
standard monomial basis of R[x]. Define the Riesz linear
functional Ly: R[x] ‚ÜíR as:
f =
X
Œ±
fŒ±xŒ± 7‚Üí
X
Œ±
fŒ±yŒ±,
‚àÄf(x) ‚ààR[x]
(4)
In words, the Riesz linear functional Ly transforms a real
polynomial f to a real number that is the inner product
between y and the vector of coefficients of f. The notation
of Ly can be naturally extended to polynomial vectors and
matrices, as illustrated in the following example.
Example
6
(Riesz
Linear
Functional).
Let
n
=
3,
I
= {1, 3}. Then [x]1
= [1; x1; x2; x3] and [x(I)]2
=

1; x1; x3; x2
1; x1x3; x2
3

. Applying Ly, we have
Ly((x1 + x3) ¬∑ [x(I)]2) =
Ô£Æ
Ô£ØÔ£ØÔ£ØÔ£ØÔ£ØÔ£ØÔ£∞
y1,0,0 + y0,0,1
y2,0,0 + y1,0,1
y1,0,1 + y0,0,2
y3,0,0 + y2,0,1
y2,0,1 + y1,0,2
y1,0,2 + y0,0,3
Ô£π
Ô£∫Ô£∫Ô£∫Ô£∫Ô£∫Ô£∫Ô£ª
,
(5)
Ly([x]1 [x]T
1 ) =
Ô£Æ
Ô£ØÔ£ØÔ£∞
y0,0,0
y1,0,0
y0,1,0
y0,0,1
y1,0,0
y2,0,0
y1,1,0
y1,0,1
y0,1,0
y1,1,0
y0,2,0
y0,1,1
y0,0,1
y1,0,1
y0,1,1
y0,0,2
Ô£π
Ô£∫Ô£∫Ô£ª,
(6)
where the number y1,0,0 is applying Ly to the monomial x1
1 ¬∑
x0
2 ¬∑ x0
3 = x1.
With the Riesz linear functional, we can state the dense
Moment-SOS hierarchy. Essentially, through the Riesz linear
functional Ly, the Moment-SOS hierarchy relaxes the original
POP (2) as a convex optimization problem whose variable
becomes the sequence y. The reason why this is called a
‚Äúhierarchy‚Äù is because one can make the sequence arbitrarily
long, depending on how many monomials are included.
Proposition 7 (Dense Moment-SOS Hierarchy). Consider
the POP (2). Let dg
j
= ‚åàdeg(gj)/2‚åâ, ‚àÄj ‚àà[mineq] and
dh
j = deg(hj), ‚àÄj ‚àà[meq]. Define
dmin=max
n
‚åàdeg(f)/2‚åâ,

dg
j
	
j‚àà[mineq] ,

dh
j /2
	
j‚àà[meq]
o
. (7)
Given a positive integer d ‚â•dmin, the d-th order dense
Moment-SOS hierarchy reads:
min
y
Ly(f)
(8a)
s.t.
Ly

[x]d [x]T
d

‚™∞0
(8b)
Ly

gj ¬∑ [x]d‚àídg
j [x]T
d‚àídg
j

‚™∞0, ‚àÄj ‚ààGl, l ‚àà[p] (8c)
Ly

hj ¬∑ [x]2d‚àídh
j

= 0, ‚àÄj ‚ààHl, l ‚àà[p]
(8d)
y0 = 1
(8e)
The optimal value of the convex optimization (8) converges to
the optimal value of the nonconvex POP (2) œÅ‚ãÜas d ‚Üí‚àû.
In (8), the matrix Ly([x]d[x]T
d) is usually called a moment
matrix and it is enforced by a positive semidefinite (PSD)
constraint. One can see that the dense Moment-SOS hierarchy
can become expensive very quickly as the relaxation order d
increases. This is because the ‚Äúdense‚Äù moment matrix at order
d has size (n+d
d ) which quickly makes the PSD constraint too
large to be handled by off-the-shelf SDP solvers (recall that the
length of the monomial basis indexing the moment matrix‚Äî
[x]d‚Äîis (n+d
d )).
Moment-SOS relaxations with CS. On the other hand,
with correlative sparsity and when the variables are divided
into cliques {Il}p
l=1 where the size of clique Il is nl, then
instead of generating a single moment matrix with size (n+d
d ),
the sparse Moment-SOS hierarchy will generate p moment
matrices where the size of each moment matrix is (nl+d
d ). A
different way to view this is that, correlative sparsity breaks a
large PSD constraint into multiple smaller PSD constraints.
Let us formalize this.
Proposition 8 (Sparse Moment-SOS Hierarchy). Consider the
POP (2) and assume its variables are grouped into cliques
{Il}p
l=1 and its constraints are grouped into Gl, Hl where Gl
and Hl include constraints only involving variables x[Il]. For
any fixed integer d ‚â•dmin (dmin defined as in (7)), define
the following polynomial matrices and vectors associated with
each clique Il as:
Md(Il) = [x(Il)]d [x(Il)]T
d , l ‚àà[p]
(9a)
Md(gj, Il) = gj ¬∑ [x(Il)]d‚àídg
j [x(Il)]T
d‚àídg
j , j ‚ààGl, l ‚àà[p]
(9b)
Hd(hj, Il) = hj ¬∑ [x(Il)]2d‚àídh
j , j ‚ààHl, l ‚àà[p]
(9c)
Let g0 := 1, then Md(g0, Il) = Md(Il). The d-th order
Moment-SOS hierarchy with correlative sparsity reads:
œÅd := min
y
Ly(f)
(10a)
s.t.
Ly (Md(gj, Il)) ‚™∞0, ‚àÄj ‚àà{0} ‚à™Gl, l ‚àà[p] (10b)
Ly (Hd(hj, Il)) = 0, ‚àÄj ‚ààHl, l ‚àà[p]
(10c)
y0 = 1
(10d)
Moreover, under appropriate compactness assumptions ,
the sequence œÅd ‚ÜíœÅ‚ãÜas d ‚Üí‚àû.
1
x1
x2
x2
1
x2
2
x1x2
1
x1
x2
1
1
x2
x2
2
Dense Moment Relaxation
Sparse Moment Relaxation
Fig. 5: Comparison of the moment matrices in dense and
sparse Moment-SOS relaxations.
As an illustrative example, suppose the POP has two vari-
ables x = (x1, x2). Then the moment matrix corresponding
to the dense Moment-SOS hierarchy at d = 2 is shown in
Fig. 5 left, where its rows and columns are indexed by the
standard monomial basis [x]2. However, suppose from the
chordal extension of the CSP graph one can find two cliques
{x1} and {x2} (i.e., they are not connected), then the sparse
Moment-SOS hierarchy at d = 2 would generate two moment
matrices shown in Fig. 5 right. From the color coding in Fig. 5,
we can see that the two smaller moment matrices are principal
submatrices of the big moment matrix. Hence, a 6 √ó 6 PSD
constraint is broken into two 3 √ó 3 PSD constraints.
It is worth mentioning that (a) while both the dense and the
sparse Moment-SOS hierarchy converge to œÅ‚ãÜ, they may, and
in general, converge at different speeds; (b) associated with
both (8) and (10) are their dual sums-of-squares (SOS) convex
relaxations (hence the name Moment-SOS hierarchy). Though
we do not explicitly state the SOS relaxations (see  and
references therein), our SPOT package implements them.
C. Term Sparsity
While correlative sparsity (CS) focuses on relationships
between variables, term sparsity (TS) addresses relationships
between monomials. Specifically, TS is designed to partition
monomial bases into blocks according to the monomial con-
nections in the POP . Rather than analyzing general TS
in isolation, we focus on the integration of CS and TS .
Similar to CS, exploiting TS is also related to constructing
a graph called the term sparsity pattern (TSP) graph. This
construction involves three steps: (a) initialization; (b) support
extension; and (c) chordal extension.
We remark that the notion of TS and the construction of the
TSP graph can be less intuitive than the CSP graph mentioned
before, and the mathematical notations can get quite involved.
However, it is safe for the reader to quickly glance the TSP
construction just to understand its high-level idea, and revisit
the math a couple more times later.
Initialization. Let Il, l ‚àà[p] be the maximal cliques of
(Gcsp)‚Ä≤, with nl := |Il| the size of each clique. Let Gl and Hl,
l ‚àà[p] be defined in the CS grouping procedure and contain
polynomial constraints related to clique Il. The variables x
are grouped into subsets x(I1), . . . , x(Il). Denote A as the
set of all monomials appearing in the POP (2), union with all
even-degree monomials:
A := supp(f) ‚à™
mineq
[
j=1
supp(gj) ‚à™
meq
[
j=1
supp(hj) ‚à™(2N)n (11)
where (2N)n is defined as {2Œ± | Œ± ‚ààNn}.
Support extension. For each l ‚àà[p] and j ‚àà{0} ‚à™Gl,
construct constraint gj‚Äôs TSP graph Gg
d,l,j with:
1) Nodes: Vd,l,j := |[x(Il)]d‚àídg
j | (these relate to monomials)
2) Edges: Ed,l,j = {(Œ≤, Œ≥) | supp(Md(gj, Il)Œ≤,Œ≥) ‚à©A Ã∏= 0},
where
Md(gj, Il)Œ≤,Œ≥ = gj ¬∑ [x(Il)]d‚àídg
j (Œ≤) ¬∑ [x(Il)]d‚àídg
j (Œ≥). (12)
For each each l ‚àà[p] and j ‚ààHl, define the binary mask
vector Bh
d,l,j as:
Bh
d,l,j(Œ≤) =
(
1,
supp(Hd(hj, Il)Œ≤) ‚à©A Ã∏= ‚àÖ
0,
otherwise
(13)
where
Hd(hj, Il)Œ≤ = hj ¬∑ [x(Il)](Œ≤).
(14)
Chordal extension. For each l ‚àà[p] and j ‚àà{0} ‚à™Gl, let
G‚Ä≤
d,l,j be the chordal extension of Gg
d,l,j. Define Bg
d,l,j as its
adjacency matrix, which is naturally a binary mask matrix.
(a)
(b)
Fig. 6: (a) Gg
2,1,1: support extension for g1 in clique I1; (b)
Gg
2,2,0: support extension for g0 in clique I2.
We shall illustrate this using our robotics example.
Example 9 (TSP Graph of Example 1). Consider the toy
example‚Äôs two cliques: I1 := {x0, v0, Œª1,0, Œª2,0} and I2 :=
{x0, x1, v0} (illustrated in Fig. 4). Define g1 := Œª1,0 + 1 + x0
and g0 := 1. Then, Gg
2,1,1 is illustrated in Fig. 6(a).
There exists an edge between x0 and Œª1,0 since x0 and
Œª1,0 appear at the second and fifth positions of x(I1)d‚àídg :=
[1, x0, v0, Œª1,0, Œª2,0]T, respectively. According to (12),
Œª2,0x0 ‚ààM2(g1, I1)2,5 = (Œª1,0 + 1 + x0) ¬∑ x0 ¬∑ Œª2,0
(15)
and Œª2,0x0 ‚ààA since Œª2,0 ¬∑ ( Œª2,0
k2 + d2 ‚àíx0) = 0.
Similarly, Gg
2,2,0 is illustrated in Fig. 6(b). There exists an
edge between x2
0 and x2
1 since x2
0 ¬∑ x2
1 is of even degree. Both
Gg
2,1,1 and Gg
2,2,0 are already chordal.
Note that the crucial difference between CSP and TSP is that
the nodes of a CSP graph are the variables while the nodes
of a TSP graph are monomials. Therefore, while the goal of
CSP is to break the entire variable x into smaller cliques of
variables, the goal of TSP is to break the dense monomial
basis [x(Il)]d into smaller cliques of monomials.
Combining CS and TS, we can further decompose the PSD
constraints in the sparse Moment-SOS hierarchy (10) into
smaller ones. Due to space constraints, we defer a formal
presentation to Appendix B. The high-level intuition, however,
is that the binary masks obtained from the TSP allow us
to only focus on the entries of the matrix variables in (10)
corresponding to nonzero entries in the masks.
D. Sparse Polynomial Optimization Toolbox (SPOT)
To automate the aforementioned sparsity exploitation, we
develop a new C++ package SPOT. Compared with the Julia
package TSSOS, SPOT is faster and also provides more op-
tions. (i) SPOT provides both general moment relaxation and
SOS relaxation, which complements TSSOS (only provides
SOS relaxation). (ii) For both CS and TS, SPOT provides four
options: (a) maximal chordal extension (MAX); (b) minimal
degree chordal extension (MD); (c) minimum fill chordal
extension (MF); (d) user-defined. (iii) SPOT provides a special
option ‚Äúpartial term sparsity‚Äù, which enables TS only for the
moment matrices and the localizing matrices (i.e., inequality
constraints), while applying CS to equality constraints. This
heuristic approach is motivated by the observation that in SOS
relaxation, tightening equality constraints merely introduces
more free variables and does not significantly impact the
solution time of an SDP solver. In many cases, partial TS
yields tighter lower bounds while keeping the computation
time nearly unchanged. (iv) Through our Matlab and Python
interface, SPOT provides a way for the user to visualize the
CSP and TSP graphs, as shown in Fig. 1. The automatic
sparsity detection pipleline is illustrated in Fig. 7.
III. ROBOTICS-SPECIFIC SPARSITY
While automatic correlative and term sparsity (CS-TS)
exploitation is powerful, it has two notable limitations. (a) It
occasionally fails to capture time, spatial, and kino-dynamical
sparsity inherent in contact-rich planning problems, such as
the Markov property described in . (b) The approach
introduced in ¬ßII heavily depends on approximate minimal
chordal extensions. Although theoretically rigorous, chordal
extensions can substantially increase the size of variable or
term cliques, resulting in scalability challenges.
To address these, we propose several robotics-specific spar-
sity patterns as auxiliary tools to complement the automatic
sparsity. Similarly, we categorize robotics-specific sparsity
patterns into two levels, (a) variable level and (b) term level.
The semi-automatic robotics-specific sparsity pattern injection
is shown in Fig. 7, marked in red.
A. Variable-level Robotics-Specific Sparsity
Kinematic chain. Numerous robotic systems exhibit chain-
like (or tree-like) mechanical structures, commonly found
in manipulation and locomotion. These structures lead to a
natural separation of kinematic and dynamic variables across
different links. For example, consider the following system:
x1,k+1 = x1,k + u1,k,
(16a)
x2,k+1 = x2,k + u2,k,
(16b)
x3,k+1 = x3,k + u3,k,
(16c)
(x1,k ‚àíx2,k)2 = r2,
(x2,k ‚àíx3,k)2 = r2
(16d)
which can be viewed as a 1-D two-link chain, with three states
(x1, x2, x3) and two geometric constraints in (16d). If only
exploring the Markov property in , a chain of cliques will
be derived, with the k‚Äôth clique containing 9 variables:
{xi,k, xi,k+1, ui,k}3
i=1 .
(17)
However, since (x1, x2), (x2, x3) forms two links, and each
ui, i ‚àà{1, 2, 3} only has direct effect on xi, we can further
decompose the clique as three cliques of size 3:
{xi,k, xi,k+1, ui,k} , i = 1, 2, 3
(18)
and four cliques of size 2:
{xi,m, xi+1,m} , i = 1, 2, m = k, k + 1,
(19)
as illustrated in Fig. 8(a). Note that this clique partition cannot
be discovered by the general sparsity pattern introduced in ¬ßII,
since the graph in Fig. 8(a) is not chordal.
Separation plane. Consider a general obstacle avoidance
task: both the robot and the obstacles can be decomposed as
a union of convex sets. We denote the decomposition of robot
as {Pi}i‚àà[m] and the decomposition of obstacles as {Qj}j‚àà[n].
For each i and j, Pi has no collision with Qj if and only if
there exists a plane Hi,j separating Pi and Qj. Consider Pi
and Qj being both 2-D polygons:
Ai,jvr,x + Bi,jvr,y + Ci,j ‚â•0, ‚àÄvr ‚ààP ‚Ä≤
is vertices
(20)
Ai,jvo,x + Bi,jvo,y + Ci,j ‚â§0, ‚àÄvo ‚ààQ‚Ä≤
js vertices
(21)
where (Ai,j, Bi,j, Ci,j) determines a 2-D separation plane
(line) Hi,j. For constraints (20), (Ai,j, Bi,j, Ci,j) has no direct
relationship between each other. Thus, in each time step,
instead of defining a large variable clique:
n
other variables, {(Ai,j, Bi,j, Ci,j)}i‚àà[m],j‚àà[n]
o
(22)
we define mn smaller variable cliques:
{other variables, (Ai,j, Bi,j, Ci,j)}i‚àà[m],j‚àà[n]
(23)
The resulting clique size is invariant to m and n, as illustrated
in Fig. 8(b). What‚Äôs more, one can check that the decomposi-
tion (23) still satisfies the running intersection property (RIP)
required in correlative sparsity pattern .
‚ÄúVariable-level‚Äù Maximal Cliques
‚ÄúVariable-level‚Äù Sparsity Graph
‚ÄúTerm-level‚Äù Sparsity Graph
‚ÄúTerm-level‚Äù Maximal Cliques
‚Ä¶
‚Ä¶
‚Ä¶
‚Ä¶
Fully Automatic
Semi-Automatic
- Kinematic chain sparsity 
- Separable contact modes 
- Separating hyperplane 
- ‚Ä¶
Chordal Extension
Chordal Extension
‚Ä¶
‚Ä¶
‚Ä¶
‚Ä¶
General Polynomial Optimization Problem (POP)
Fig. 7: Overall pipeline of the Sparse Polynomial Optimization Toolbox (SPOT). Blue curves: the automatic detection of
correlative and term sparsity patterns. Red curves: semi-automatic injection of robotics-specific sparsity patterns.
(a) Kinematic chain
(b) Separation plane
(c) Separable contact
Fig. 8: Robotics-specific sparsity patterns.
B. Term-level Robotics-Specific Sparsity
Separable contact modes. Frequently in contact-rich plan-
ning, we will have to ‚Äúselect one out of a bunch of modes‚Äù (cf.
¬ßC2 and¬ßC3). It can be modelled as polynomial equalities:
h0 ‚âú
X
i‚àà[n]
Œª2
i ‚àí1 = 0
(24)
hi ‚âúŒªi ¬∑ (1 ‚àíŒªi) = 0, ‚àÄi ‚àà[n] ,
(25)
where Œªi is a binary variable corresponding to whether the i-th
contact mode is selected. In variable level, there is no sparsity
in (24), since P
i‚àà[n] Œª2
i = 1 groups all Œªi‚Äôs together. However,
we show that the sparsity is still rich in the term level. Consider
the generation procedure of A in term sparsity (11), for the
polynomial equality constraint system (24):
A =
n
1, {Œªi}i‚àà[n] ,

Œª2
i
	
i‚àà[n]
o
.
(26)
Consider the special case n = 3 in second-order relaxation
d = 2, and there is only one variable clique (i.e., l = 1).
By definition of the polynomial multiplier H2(hi, I1), i ‚àà
{0, 1, 2, 3} for equality constraints (9c):
H2(hi, I1)=

1, Œª1, Œª2, Œª3, Œª2
1, Œª1Œª2, Œª1Œª3, Œª2
2, Œª2Œª3, Œª2
3
T. (27)
If we proceed with the support extension procedure for equal-
ity constraints (13), then we have
Bh
2,1,0 = [1, 1, 1, 1, 1, 0, 0, 1, 0, 1]
(28)
Bh
2,1,1 = [1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
(29)
Bh
2,1,2 = [1, 0, 1, 0, 0, 0, 0, 0, 0, 0]
(30)
Bh
2,1,2 = [1, 0, 0, 1, 0, 0, 0, 0, 0, 0]
(31)
In the second-order moment matrix, the unmasked terms are:
1, {Œªi}i‚àà ,

Œª2
i
	
i‚àà ,

Œª3
i
	
i‚àà ,

Œª4
i
	
i‚àà ,

ŒªiŒª2
j
	
i‚àà,j‚àà,iÃ∏=j
(32)
leading to the moment matrix generated by a reduced basis:

1, Œª1, Œª2, Œª3, Œª2
1, Œª2
2, Œª2
3
	
(33)
as shown in Fig. 8(c). The key observation is that there is
no ŒªiŒªj(i Ã∏= j) in the new basis (i.e., the contact modes are
separated). For a general n, the reduced basis is of size 2n+1,
which is much smaller than the standard monomial basis of
size (n+1)(n+2)
2
.
Separable contact forces. In contact-implicit formulation,
each possible contact is modelled as a set of complementary
constraints. Suppose there are n contact points, then a typical
dynamics formulation is (cf. ¬ßC1 and ¬ßC5):
0 ‚â§Œªi ‚ä•gi(x) ‚â•0, i ‚àà[n]
(34)
X
i‚àà[n]
fi(Œªi, x, u) = 0
(35)
where x ‚ààRnx is the system state and u ‚ààRnu is
the control input. Similar to the contact mode case (24),
P
i‚àà[n] fi(Œªi, x, u) groups all Œªi‚Äôs together. Thus, there is
no variable-level sparsity pattern. However, inspired by the
reduced basis introduced in (33), we can directly write down
an extended reduced basis containing x and u. For simplicity,
assume x and u are both of one dimension, fi is of quadratic
form and linear in Œªi, then the reduced basis is

1,x,u,x2,xu,u2,
{Œªi}i‚àà[n],{Œª2
i}i‚àà[n],{xŒªi}i‚àà[n],{uŒªi}i‚àà[n]

(36)
which grows linearly in n.
Although we introduce these robotics-specific sparsity
patterns in the context of contact-rich motion planning,
many‚Äîsuch as kinematic-chain structures and supporting-
hyperplane constraints‚Äîare generic and apply equally well
to tasks that do not involve contact.
IV. EXPERIMENTS
d1
d2
a
Œ∏
k1
k2
Œª2
Œª1
(a)
2a
2b
S
W
Œ∏
(sx, sy)
(px, py)
Fx
Fy
Œª1
Œª2
Œª3
Œª4
(b)
S
l
3l
4l
1.5l
dc ‚ãÖl
(x1, y2)
(x2, y2)
(x3, y2)
(x4, y2)
(x1, y3)
(x4, y3)
(x2, y1)
(x3, y1)
(px, py)
Fx
Fy
Œª1
Œª2
Œª3
Œª4
Œª6
Œª7
Œª8
(c)
(px, py)
Fx
Fy
(d)
r
R
l
l
l
l
l
Œ∏ld
Œ∏lu
Œ∏ru
Œ∏rd
Œ±
Lu
Ld
H/2
W
H/2
(x, y)
(xl, yl)
(xr, yr)
vx,r
vy,r
vx
vy
œâ
vrel
Œªt
Œªn
ÃÇt
ÃÇn
contact model
l + r
r
l + r
r
self collision
(e)
Fig. 9: illustrations of five contact-rich planning tasks. (a) Push
Bot; (b) Push Box; (c) Push T-block; (d) Push Box with a
Tunnel; (e) Planar Hand.
General setup. We consider five contact-rich problems.
1) Push Bot: A cart-pole system between two soft walls,
shown in Fig. 9(a). The objective is to stabilize the cart-
pole at (a, Œ∏) = (0, œÄ). For polynomial dynamics and
other detailed settings, please refer to Appendix C1.
2) Push Box: A simple pusher-slider system, illustrated in
Fig. 9(b). The goal is to push the box from an initial
configuration (sx, sy, Œ∏) to a target configuration. There
are 4 possible contact modes at each time step. Detailed
settings can be found in Appendix C2.
3) Push T-Block: Similar to Push Box, but the box is
replaced with a T-block, resulting in 8 possible contact
modes at each time step, as shown in Fig. 9(c). Please
refer to Appendix C3 for detailed settings.
4) Push Box with a Tunnel: Similar to Push Box, except
that two circular obstacles form a tunnel along the box‚Äôs
path to its goal, as shown in Fig. 9(d). Detailed settings
are provided in Appendix C4.
5) Planar Hand: A two-fingered system rotating a 2D disk
in a horizontal plane, as shown in Fig. 9(e). The goal is
to rotate the disk by 360‚ó¶using two fingertip contacts
while minimizing the translation of the disk‚Äôs center of
mass. See Appendix C5 for further details.
Additionally, extensive real-world validations are conducted
for the Push T task. Experiments were performed on a high-
performance workstation equipped with a 2.7 GHz AMD
64-Core sWRX8 Processor and 1 TB of RAM, enabling
MOSEK  to solve large-scale problems utilizing 64 threads.
Conversion speed. We compare SPOT and TSSOS in terms
of conversion time across the five planning problems, consid-
ering different CS and TS options. In all cases, the planning
horizon is set to N = 30. For the Push Box with a Tunnel
problem, the CS relaxation order is set to d = 3 to obtain a
tighter lower bound, while for the other examples, d is set to 2.
The results are summarized in Table I. SPOT consistently out-
performs TSSOS, achieving at least a 2√ó speedup. For large-
scale problems such as Push Box with a Tunnel, SPOT achieves
approximately a 5√ó speedup. For the Planar Hand problem,
the automatic CS pattern generation produces clique sizes
exceeding 20 through both MF and MD methods, resulting in a
large-scale SDP with over 1 million constraints. Since TSSOS
tightly integrates its conversion and SDP solving processes, it
is difficult to isolate the conversion time. Therefore, we only
report SPOT‚Äôs conversion time for this case, which remains
under 100 seconds despite the problem‚Äôs scale.
Sparsity
CS
MF
MD
Examples
TS
MAX
MF
MD
MAX
MF
MD
Push Bot
MOMENT
2.33
2.29
2.13
2.03
1.99
1.82
SOS
2.39
2.43
2.26
2.09
2.13
1.97
TSSOS
4.32
14.95
19.58
3.49
15.90
16.91
Push Box
MOMENT
1.68
1.58
1.52
1.39
1.31
1.24
SOS
1.64
1.65
1.57
1.37
1.37
1.30
TSSOS
4.56
8.83
10.12
3.94
9.60
8.92
Push T
MOMENT
3.67
3.58
3.29
4.01
3.95
3.48
SOS
3.70
3.77
3.47
4.06
4.16
3.67
TSSOS
15.54
42.86
43.41
13.13
43.22
45.02
Tunnel
MOMENT
21.19
18.03
16.19
19.78
19.79
17.69
SOS
20.55
18.62
16.81
22.76
20.81
18.63
TSSOS
90.37
109.25
112.20
83.47
129.17
125.63
Planar Hand
MOMENT
74.35
75.60
64.98
67.54
68.31
58.53
SOS
88.60
91.35
80.70
80.70
83.14
70.75
TSSOS
‚Äì
‚Äì
‚Äì
‚Äì
‚Äì
‚Äì
TABLE I: Conversion time comparison between SPOT and
TSSOS across examples, with different CS-TS options.
Self-defined variable cliques. Since the automatic sparsity
exploitation mechanism may fail to detect robotics-specific
sparsity, we adopt the following clique generation procedure:
1) Generate a general sparsity pattern using SPOT.
2) Manually inspect the variable cliques to determine
whether certain robotics-specific variable-level sparsity
patterns can be incorporated.
3) Modify the generated cliques and resend them to SPOT
using the ‚ÄúSELF‚Äù option.
For example, in the Planar Hand task, leveraging the kine-
matic chain pattern discussed in ¬ßIII, we manually partition
the variables at each time step into 14 smaller cliques, with
sizes ranging from 6 to 14. Due to space constraints, these
cliques are detailed in Appendix D. These manually defined
cliques precisely correspond to the red circles in Fig. 1(a),
illustrating the specific sparsity pattern.
Robust minimizer extraction. Due to the inherent com-
plexity of contact-rich planning problems, it is not uncommon
to encounter two types of relaxation ‚Äúfailure cases‚Äù:
1) The sparse Moment-SOS Hierarchy is not tight.
2) The sparse Moment-SOS Hierarchy is tight but admits
multiple solutions.
In both cases, the moment matrices fail to attain rank 1 (or
other general tightness certificates). To extract minimizers,
TSSOS and  both employ the same ‚Äúnaive‚Äù approach:
obtain the degree-1 submatrix of each moment matrix, then
average the normalized eigenvectors across different variable
cliques. While straightforward to implement, this method
is not robust in practice, often leading to infeasible local
rounding and large suboptimality gaps. On the other hand, 
demonstrates that the Gelfand-Naimark-Segal (GNS) construc-
tion provides a robust approach for minimizer extraction from
a single moment matrix. Inspired by this, we propose the
following heuristic algorithm for minimizer extraction in the
presence of multiple moment matrices:
1) For each moment matrix, extract minimizers along with
their associated weights using the GNS construction.
2) Select the minimizer with the highest weight and average
it across different variable cliques.
This seemingly minor modification significantly improves
robustness compared to the ‚Äúnaive‚Äù extraction method. We
implemented the new minimizer extraction scheme in our
SPOT package. A detailed discussion of GNS is beyond the
scope of this paper; we refer interested readers to .
Numerical results. The results are presented in Table II.
The planning horizon N is set to 30. For the Push Bot, Push
Box, and Push T Block tasks, we evaluate 10 random initial
states. For the Push Box with a Tunnel and Planar Hand tasks,
we consider 5 random initial states. All reported statistics
represent mean values. From semidefinite relaxation, we can
get a lower bound flower of original nonconvex POP. After
extracting solution, we use an in-house local solver to round a
feasible solution with an upper bound fupper. The suboptimality
gap is defined as:
Œ∑g :=
|flower ‚àífupper|
1 + |flower| + |fupper|
(37)
We also report max KKT residual Œ∑kkt and MOSEK solving
time. Since SOS relaxation tends to generate much less con-
straint numbers compared to moment relaxation, and MOSEK is
sensitive to constraint numbers, we only test SOS relaxations.
The numerical results reveal a clear trade-off between
computational efficiency and relaxation tightness. When TS
is not enabled, all average suboptimality gaps remain below
10%, except for the Planar Hand task. However, solving large-
scale problems can take up to 5 minutes. Enabling TS with
MF significantly improves computational efficiency. For the
Push Bot, Push Box, and Push T Block tasks, we achieve
near real-time solving speeds. However, this comes at the cost
of significantly larger suboptimality gaps. In all of our case
studies, the local solver recovered trajectories that succeed the
tasks. Notably, there are two instances where MOSEK fails to
solve the SDP to high accuracy: (a) Push Bot, SELF + MAX;
(b) Planar Hand, SELF + MF. The underlying causes of these
failures remain unknown. We also report the corresponding
SDP constraint number, PSD cone number, and max PSD
cone size in Table III. The demonstration of global optimal
trajectories can be found in Fig. 10.
Real-world Push T-Block validations. We extensively val-
idate our global optimal policy in the real world Push T-Block
setting, as illustrated in Fig. 1(c). We use AprilTag  to get
accurate pose estimation of the T-block. Due to the global
optimality of our approach, a planning horizon of N = 5
is sufficient to generate high-quality planned trajectories. At
each time step, we execute the pusher‚Äôs first action and then
re-plan. The average re-planning time is 3.7 seconds, with CS
set to MF and TS set to NON. We evaluate our framework
in 20 random trials, evenly split between two categories:
clean push-T tasks, which involve standard push-T scenarios
without disturbances, and ‚Äúdirty‚Äù push-T tasks, where severe
model mismatches and external disturbances are introduced
to assess the planner‚Äôs robustness. These disturbances include
cases where the T-block is wrapped in a cable, put on some
irregular surface, or contained within a small box. These
three scenarios correspond to lines 2-4 in Fig. 1(c). Note
that all these ‚Äúdirty‚Äù push-T cases make our modeling (which
is very simple) effectively ‚Äúwrong‚Äù. However, our planner
demonstrates remarkable efficiency and robustness across all
test cases, achieving a 100% success rate while naturally
accommodating a wide range of initial states and challenging
environments. For more demonstrations, please see Fig. 11 and
our attached supplementary materials.
V. CONCLUSION
We introduced a new paradigm to contact-rich motion
planning by exploiting both generic and robotics-specific spar-
sity patterns within semidefinite relaxations. Our method effi-
ciently exploits correlative, term, and robotics-specific sparsity,
enabling near-global optimization of complex robotic motion
planning tasks. Through the Sparse Polynomial Optimization
Toolbox (SPOT), we automated sparsity detection, significantly
reducing computation time while maintaining solution quality.
Extensive experiments, including various real-world push-T
validations, demonstrated the robustness of our approach.
Examples
SELF + NON
SELF + MAX
SELF + MF
Œ∑g (%)
‚àílog10(Œ∑kkt)
time (s)
Œ∑g (%)
‚àílog10(Œ∑kkt)
time (s)
Œ∑g (%)
‚àílog10(Œ∑kkt)
time (s)
Push Bot
0.08
5.90
22.07
9.28
3.67
14.01
32.39
5.47
5.21
Push Box
0.15
5.65
8.90
0.20
5.70
5.76
13.77
6.37
1.67
Push T
7.83
5.30
46.20
17.10
5.67
29.35
35.98
5.50
4.99
Tunnel
4.89
5.52
342.31
5.22
5.35
266.17
8.20
5.04
33.31
Planar Hand
22.26
5.00
343.79
23.97
5.15
143.42
25.61
3.94
54.00
TABLE II: Comparison of suboptimality gap Œ∑g, max KKT residual Œ∑kkt, and MOSEK solving times for different tasks under
SELF + NON, SELF + MAX, and SELF + MF settings. Throughout the table, we only consider SOS relaxation.
Examples
SELF + NON
SELF + MAX
SELF + MF
Constraint
PSD Cone
Max PSD
Constraint
PSD Cone
Max PSD
Constraint
PSD Cone
Max PSD
Number
Number
Cone Size
Number
Number
Cone Size
Number
Number
Cone Size
Push Bot
45183
1429
66
32807
6310
32
11457
14489
11
Push Box
38869
1316
45
27631
6043
35
12212
11456
9
PushT
101080
1476
91
67656
8589
59
27777
18875
13
Tunnel2
279547
1260
165
222503
27549
12
53553
46322
13
Planar Hand
405740
4733
120
256654
25091
15
104097
57569
13
TABLE III: Comparison of constraint number, PSD cone number, and max PSD cone size for different tasks under SELF +
NON, SELF + MAX, and SELF + MF settings. Throughout the table, only SOS relaxation are considered.
(a) Push Bot
(b) Push Box
(d) Push Box with a Tunnel
(e) Planar Hand
(c) Push T-Block
Fig. 10: More globally optimal trajectories from SPOT.
Fig. 11: More demonstrations from real-world ‚Äúdirty‚Äù push-T tasks. From top to bottom: T-block (1) contained in a box; (2)
sits on top of some irregular surfaces; (3) attached to some irregular objects; (4) stacked with another T-block; (5) put on some
irregular objects.
Limitations and future work. Despite its efficiency, our
approach faces challenges in scalability, suboptimality gaps,
and real-time execution. Large-scale problems with many con-
tact modes still pose computational bottlenecks, and automatic
sparsity detection can lead to oversized relaxations. Future
improvements can explore GPU-accelerated first-order SDP
solvers , hybrid relaxations, and learning-based heuris-
tics to further advance real-time and large-scale applications.
Moreover, at present, sparsity patterns are crafted individually
for each problem, but we anticipate that our open-source SPOT
package‚Äîdesigned for rapid experimentation with alternative
sparsity structures‚Äîwill spur the discovery of many more.
REFERENCES
 Mosek ApS.
Mosek optimization toolbox for matlab.
User‚Äôs Guide and Reference Manual, Version, 4(1), 2019.
9
 Alp Aydinoglu and Michael Posa.
Real-time multi-
contact model predictive control via admm.
In 2022
International Conference on Robotics and Automation
(ICRA), pages 3414‚Äì3421. IEEE, 2022. 2
 Alp Aydinoglu, Philip Sieg, Victor M Preciado, and
Michael Posa. Stabilization of complementarity systems
via contact-aware controllers.
IEEE Transactions on
Robotics, 38(3):1735‚Äì1754, 2021. 2
 Hans L. Bodlaender and Arie M.C.A. Koster. Treewidth
computations i. upper bounds. Information and Compu-
tation, 208(3):259‚Äì275, 2010. ISSN 0890-5401. 4
 Jan Br√ºdigam, Stefan Sosnowski, Zachary Manchester,
and Sandra Hirche.
Variational integrators and graph-
based solvers for multibody dynamics in maximal co-
ordinates. Multibody System Dynamics, 61(3):381‚Äì414,
2024. 2
 Iordanis Chatzinikolaidis and Zhibin Li.
Trajectory
optimization of contact-rich motions using implicit dif-
ferential dynamic programming.
IEEE Robotics and
Automation Letters, 6(2):2626‚Äì2633, 2021. 2
 Claire Chen, Preston Culbertson, Marion Lepert, Mac
Schwager, and Jeannette Bohg. Trajectotree: Trajectory
optimization meets tree search for planning multi-contact
dexterous manipulation. In 2021 IEEE/RSJ International
Conference on Intelligent Robots and Systems (IROS),
pages 8262‚Äì8268. IEEE, 2021. 2
 Xianyi Cheng, Eric Huang, Yifan Hou, and Matthew T
Mason.
Contact mode guided motion planning for
quasidynamic dexterous manipulation in 3d.
In 2022
International Conference on Robotics and Automation
(ICRA), pages 2730‚Äì2736. IEEE, 2022. 2
 Jared Di Carlo, Patrick M Wensing, Benjamin Katz,
Gerardo Bledt, and Sangbae Kim. Dynamic locomotion
in the mit cheetah 3 through convex model-predictive
control. In 2018 IEEE/RSJ international conference on
intelligent robots and systems (IROS), pages 1‚Äì9. IEEE,
2018. 1
 Yanran Ding, Chuanzheng Li, and Hae-Won Park. Kino-
dynamic motion planning for multi-legged robot jumping
via mixed-integer convex program. In 2020 IEEE/RSJ In-
ternational Conference on Intelligent Robots and Systems
(IROS), pages 3998‚Äì4005. IEEE, 2020. 2
 Delbert Ray Fulkerson and Oliver Alfred Gross. Inci-
dence matrices and interval graphs. Pacific Journal of
Mathematics, 15:835‚Äì855, 1965. 4
 Martin Charles Golumbic. Algorithmic graph theory and
perfect graphs. Elsevier, 2004. 4
 Bernhard P Graesdal, Shao YC Chia, Tobia Mar-
cucci, Savva Morozov, Alexandre Amice, Pablo A Par-
rilo, and Russ Tedrake.
Towards tight convex relax-
ations for contact-rich manipulation.
arXiv preprint
arXiv:2402.10312, 2024. 2, 17
 Kazuo Hirai, Masato Hirose, Yuji Haikawa, and Toru
Takenaka. The development of honda humanoid robot.
In Proceedings. 1998 IEEE international conference on
robotics and automation (Cat. No. 98CH36146), vol-
ume 2, pages 1321‚Äì1326. IEEE, 1998. 1
 Lei Huang, Shucheng Kang, Jie Wang, and Heng Yang.
Sparse polynomial optimization with unbounded sets.
arXiv preprint arXiv:2401.15837, 2024. 2
 Shucheng Kang, Xiaoyang Xu, Jay Sarva, Ling Liang,
and Heng Yang. Fast and certifiable trajectory optimiza-
tion. arXiv preprint arXiv:2406.05846, 2024. 2, 3, 7, 10,
12
 Igor Klep, Janez Povh, and Jurij Volcic.
Minimizer
extraction in polynomial optimization is robust. SIAM
Journal on Optimization, 28(4):3177‚Äì3207, 2018. 3, 10
 Frans Anton Koolen. Balance control and locomotion
planning for humanoid robots using nonlinear centroidal
models. PhD thesis, Massachusetts Institute of Technol-
ogy, 2020. 2
 Jean B Lasserre. Global optimization with polynomials
and the problem of moments.
SIAM Journal on opti-
mization, 11(3):796‚Äì817, 2001. 2
 Jean B Lasserre.
Convergent sdp-relaxations in poly-
nomial optimization with sparsity.
SIAM Journal on
optimization, 17(3):822‚Äì843, 2006. 6
 Jean B Lasserre.
Convergent sdp-relaxations in poly-
nomial optimization with sparsity.
SIAM Journal on
optimization, 17(3):822‚Äì843, 2006. 2, 7
 Simon Le Cleac‚Äôh, Taylor A Howell, Shuo Yang, Chi-
Yen Lee, John Zhang, Arun Bishop, Mac Schwager,
and Zachary Manchester.
Fast contact-implicit model
predictive control. IEEE Transactions on Robotics, 2024.
2
 Taeyoung Lee.
Computational geometric mechanics
and control of rigid bodies. PhD thesis, University of
Michigan, 2008. 2, 16
 Kevin M Lynch, Hitoshi Maekawa, and Kazuo Tanie.
Manipulation and active sensing by pushing using tactile
feedback. In IROS, volume 1, pages 416‚Äì421, 1992. 18
 Victor Magron and Jie Wang. Tssos: a julia library to
exploit sparsity for large-scale polynomial optimization.
arXiv preprint arXiv:2103.00915, 2021. 2, 3
 Victor Magron and Jie Wang. Sparse polynomial opti-
mization: theory and practice. World Scientific, 2023.
2
 Zachary Manchester and Scott Kuindersma. Variational
contact-implicit trajectory optimization. In Robotics Re-
search: The 18th International Symposium ISRR, pages
985‚Äì1000. Springer, 2020. 2
 Tobia Marcucci and Russ Tedrake. Warm start of mixed-
integer programs for model predictive control of hybrid
systems. IEEE Transactions on Automatic Control, 66
(6):2433‚Äì2448, 2020. 2
 Matthew T Mason. Mechanics and planning of manip-
ulator pushing operations. The International Journal of
Robotics Research, 5(3):53‚Äì71, 1986. 1, 17
 Carlos Mastalli, Rohan Budhiraja, Wolfgang Merkt,
Guilhem Saurel, Bilal Hammoud, Maximilien Naveau,
Justin Carpentier, Ludovic Righetti, Sethu Vijayakumar,
and Nicolas Mansard.
Crocoddyl: An efficient and
versatile framework for multi-contact optimal control. In
2020 IEEE International Conference on Robotics and
Automation (ICRA), pages 2536‚Äì2542. IEEE, 2020. 2
 Igor Mordatch, Emanuel Todorov, and Zoran Popovi¬¥c.
Discovery
of
complex
behaviors
through
contact-
invariant optimization. ACM Transactions on Graphics
(ToG), 31(4):1‚Äì8, 2012. 2
 Savva Morozov, Tobia Marcucci, Alexandre Amice,
Bernhard Paus Graesdal, Rohan Bosworth, Pablo A
Parrilo, and Russ Tedrake.
Multi-query shortest-path
problem in graphs of convex sets.
arXiv preprint
arXiv:2409.19543, 2024. 2
 Edwin Olson.
Apriltag: A robust and flexible visual
fiducial system. In 2011 IEEE international conference
on robotics and automation, pages 3400‚Äì3407. IEEE,
2011. 10
 Tao Pang, HJ Terry Suh, Lujie Yang, and Russ Tedrake.
Global planning for contact-rich manipulation via local
smoothing of quasi-dynamic contact models.
IEEE
Transactions on robotics, 2023. 2
 Michael Posa, Cecilia Cantu, and Russ Tedrake.
A
direct method for trajectory optimization of rigid bodies
through contact. The International Journal of Robotics
Research, 33(1):69‚Äì81, 2014. 2, 20
 Donald J Rose, R Endre Tarjan, and George S Lueker.
Algorithmic aspects of vertex elimination on graphs.
SIAM Journal on computing, 5(2):266‚Äì283, 1976. 4
 Yuval Tassa, Tom Erez, and Emanuel Todorov. Synthesis
and stabilization of complex behaviors through online
trajectory optimization. In 2012 IEEE/RSJ International
Conference on Intelligent Robots and Systems, pages
4906‚Äì4913. IEEE, 2012. 2
 Yuval Tassa, Nicolas Mansard, and Emo Todorov.
Control-limited differential dynamic programming.
In
2014 IEEE International Conference on Robotics and
Automation (ICRA), pages 1168‚Äì1175. IEEE, 2014. 2
 Sangli Teng, Ashkan Jasour, Ram Vasudevan, and Maani
Ghaffari.
Convex geometric motion planning on lie
groups via moment relaxation. In Robotics: Science and
Systems, 2023. 2, 3, 16
 Sangli Teng, Ashkan Jasour, Ram Vasudevan, and Maani
Ghaffari. Convex geometric motion planning of multi-
body systems on lie groups via variational integrators and
sparse moment relaxation. The International Journal of
Robotics Research, page 02783649241296160, 2024. 2,
3
 Hayato Waki, Sunyoung Kim, Masakazu Kojima, and
Masakazu Muramatsu.
Sums of squares and semidef-
inite program relaxations for polynomial optimization
problems with structured sparsity.
SIAM Journal on
Optimization, 17(1):218‚Äì242, 2006. 4
 Jie Wang. An introduction to polynomial optimization.
2023. 16
 Jie Wang, Victor Magron, and Jean-Bernard Lasserre.
Tssos: A moment-sos hierarchy that exploits term spar-
sity. SIAM Journal on optimization, 31(1):30‚Äì58, 2021.
2, 6
 Jie Wang, Victor Magron, Jean B Lasserre, and Ngoc
Hoang Anh Mai. Cs-tssos: Correlative and term sparsity
for large-scale polynomial optimization. ACM Transac-
tions on Mathematical Software, 48(4):1‚Äì26, 2022. 6,
16
 Albert Wu, Sadra Sadraddini, and Russ Tedrake. R3t:
Rapidly-exploring random reachable set tree for optimal
kinodynamic planning of nonlinear hybrid systems. In
2020 IEEE International Conference on Robotics and
Automation (ICRA), pages 4245‚Äì4251. IEEE, 2020. 2
 Heng Yang.
Semidefinite optimization and relax-
ation. Lecture notes: 
Semidefinite/, 2024. 6
 Heng Yang and Luca Carlone. Certifiably optimal outlier-
robust geometric perception: Semidefinite relaxations and
scalable global optimization.
IEEE transactions on
pattern analysis and machine intelligence, 45(3):2816‚Äì
2834, 2022. 2
 Lujie Yang, Tobia Marcucci, Pablo A Parrilo, and Russ
Tedrake. A new semidefinite relaxation for linear and
piecewise-affine optimal control with time scaling. 2
 William Yang and Michael Posa.
Dynamic on-palm
manipulation via controlled sliding.
arXiv preprint
arXiv:2405.08731, 2024. 2
 Mihalis Yannakakis.
Computing the minimum fill-in
is np-complete.
SIAM Journal on Algebraic Discrete
Methods, 2(1):77‚Äì79, 1981. 4
 K. Yunt.
Optimal trajectory planning for structure-
variant mechanical systems. In International Workshop
on Variable Structure Systems, 2006. VSS‚Äô06., pages
298‚Äì303, 2006. doi: 10.1109/VSS.2006.1644534. 2
 Kerim Yunt and Christoph Glocker. A combined con-
tinuation and penalty method for the determination of
optimal hybrid mechanical trajectories. In Iutam Sym-
posium on Dynamics and Control of Nonlinear Systems
with Uncertainty: Proceedings of the IUTAM Symposium
held in Nanjing, China, September 18-22, 2006, pages
187‚Äì196. Springer, 2007. 2
APPENDIX
A. MD and MF Chordal Extension
We present the MD chordal extension algorithm, which selects vertices based on minimum degree for elimination ordering.
Algorithm 1: MD Chordal Extension
Input: Graph G(V, E) with n vertices
Output: Chordal graph G‚Ä≤, elimination order œÄ
1 G‚Ä≤ ‚ÜêG, H ‚ÜêG, R ‚ÜêV ;
2 for i = 1 to n do
3
Find vertex v ‚ààR with minimum degree in H;
4
œÄ(v) ‚Üêi;
5
// Unprocessed neighbors;
6
N ‚Üê{u ‚ààR : (v, u) ‚ààE(H)};
7
for each pair (u, w) ‚ààN √ó N, u Ã∏= w do
8
if (u, w) /‚ààE‚Ä≤ then
9
Add edge (u, w) to G‚Ä≤ and H;
10
Remove edges (v, u) in H, ‚àÄu ‚ààN;
11
end
12
end
13
R ‚ÜêR \ {v};
14 end
We also present the MF chordal extension algorithm, which selects vertices causing minimum fill-in edges during the
elimination process.
Algorithm 2: MF Chordal Extension
Input: Graph G(V, E) with n vertices
Output: Chordal graph G‚Ä≤, elimination order œÄ
1 G‚Ä≤ ‚ÜêG, H ‚ÜêG, R ‚ÜêV ;
2 for i = 1 to n do
3
For each v ‚ààR, compute fill-in cost: fill-in(v) = |{(u, w) : u, w ‚ààNH(v), u Ã∏= w, (u, w) /‚ààE(H)}|;
4
Find vertex v ‚ààR with minimum fill-in(v) in H;
5
œÄ(v) ‚Üêi;
6
// Unprocessed neighbors;
7
N ‚Üê{u ‚ààR : (v, u) ‚ààE(H)};
8
for each pair (u, w) ‚ààN √ó N, u Ã∏= w do
9
if (u, w) /‚ààE‚Ä≤ then
10
Add edge (u, w) to G‚Ä≤ and H;
11
Remove edges (v, u) in H, ‚àÄu ‚ààN;
12
end
13
end
14
R ‚ÜêR \ {v};
15 end
B. Moment-SOS Hierarchy with CS-TS
Given a graph G(V, E), define:
SG =
n
Q ‚ààS|V |  QŒ≤,Œ≥ = QŒ≥,Œ≤ = 0, ‚àÄŒ≤ Ã∏= Œ≥, (Œ≤, Œ≥) /‚ààE
o
(A1)
where the rows and columns of Q ‚ààSG are indexed by V . Let Œ†G be the projection form S|V | to the subspace SG. Specifically,
forall Q ‚ààS|V |:
Œ†G(Q) =
(
QŒ≤,Œ≥,
Œ≤ = Œ≥ or (Œ≤, Œ≥) ‚ààE
0,
otherwise
(A2)
If we further define Œ†G(S|V |
+ ) as
n
Œ†G(Q)
 Q ‚ààS|V |
+
o
, the image of PSD cone with under projection Œ†G(¬∑), then the
Moment-SOS Hierarchy with combined CS and TS can be concretely written as:
min
Ly(f)
(A3)
s.t.
Ly (Md(gj, Il)) ‚ó¶Bg
d,l,j ‚ààŒ†G‚Ä≤
d,l,j(S|Vd,l,j|
+
),
‚àÄj ‚àà{0} ‚à™Gl, l ‚àà[p]
(A4)
Ly (Hd(hj, Il)) ‚ó¶Bh
d,l,j = 0, ‚àÄj ‚ààHl, l ‚àà[p]
(A5)
y0 = 1
(A6)
The above procedure outlines the CS-TS Moment-SOS Hierarchy with a sparse order of k = 1. As shown in , one can
further iteratively apply support extension and chordal extension within term sparsity. This process generates new sets Bg
d,l,j
and Bh
d,l,j, leading to a two-level hierarchy:
1) The outer level is governed by CS‚Äôs relaxation order d.
2) The inner level is controlled by TS‚Äôs sparse order k, which corresponds to the number of iterations used to generate new
Bg
d,l,j and Bh
d,l,j.
Define the optimal value of (A3) as œÅk
d. The sequence {œÅk
d}k‚â•1 is monotonically non-decreasing and satisfies œÅk
d ‚â§œÅd for all
k. What‚Äôs more:
Theorem A1 (Theorem 4.26 in ). If we use maximal chordal extension (i.e., block closure) for term sparsity, œÅk
d ‚ÜíœÅd as
k ‚Üí‚àû.
C. Polynomial Dynamics of Robotics Systems
1) Push Bot: Push bot is essentially cart-pole with soft wall. The configuration is shown in Figure 9 (a). a is cart‚Äôs position,
Œ∏ is pole‚Äôs angle, k1 and k2 is soft wall‚Äôs elastic modulus, Œª1 and Œª2 is two contact forces between two walls and pole‚Äôs tip.
The goal is to stabilize the cart-pole to (a, Œ∏) = (0, œÄ). From Newtonian mechanics:
(mc + mp) d2
dt2 a + mp‚Ñìd2
dt2 (sin Œ∏) ‚àí(u + Œª1 ‚àíŒª2) = 0
(A7)
‚Ñìd2
dt2 Œ∏ + ( d2
dt2 a + Œª2 ‚àíŒª1) cos Œ∏ + g sin Œ∏ = 0
(A8)
0 ‚â§Œª1 ‚ä•Œª1
k1
+ d1 + (a + ‚Ñìsin Œ∏) ‚â•0
(A9)
0 ‚â§Œª2 ‚ä•Œª2
k2
+ d2 ‚àí(a + ‚Ñìsin Œ∏) ‚â•0
(A10)
Use the same techniques introduced in , we discretize (A7) on the lie group  to yield polynomial dynamics:
(mc + mp) ¬∑ ak+1 ‚àí2ak + ak‚àí1
‚àÜt2
+ (mp‚Ñì) ¬∑ rs,k+1 ‚àí2rs,k + rs,k‚àí1
‚àÜt2
‚àí(uk + Œª1,k ‚àíŒª2,k) = 0
(A11)
‚Ñì¬∑ fs,k ‚àífs,k‚àí1
‚àÜt2
+
ak+1 ‚àí2ak + ak‚àí1
‚àÜt2
+ (Œª2,k ‚àíŒª1,k)

¬∑ rc,k + g ¬∑ rs,k = 0
(A12)
0 ‚â§Œª1,k ‚ä•
Œª1,k
k1
+ d1 + ak + ‚Ñìrs,k

‚â•0
(A13)
0 ‚â§Œª2,k ‚ä•
Œª2,k
k2
+ d2 ‚àíak ‚àí‚Ñìrs,k

‚â•0
(A14)
rc,k = rc,k‚àí1fc,k‚àí1 ‚àírs,k‚àí1fs,k‚àí1
(A15)
rs,k = rs,k‚àí1fc,k‚àí1 + rc,k‚àí1fs,k‚àí1
(A16)
r2
c,k + r2
s,k = 1
(A17)
f 2
c,k + f 2
s,k = 1
(A18)
The loss function is designed as:
loss =
N‚àí1
X
k=0
ca ¬∑ a2
k + ca,f ¬∑ a2
N
+
N‚àí1
X
k=0
cŒ∏ ¬∑

(rc,k + 1)2 + r2
s,k
	
+ cŒ∏,f ¬∑

(rc,N + 1)2 + r2
s,N
	
+
N‚àí1
X
k=0
c ÀôŒ∏ ¬∑

(fc,k ‚àí1)2 + f 2
s,k
	
+ c ÀôŒ∏,f ¬∑

(fc,N ‚àí1)2 + f 2
s,N
	
(A19)
2) Push Box: Consider a simple pusher-slider system illustrated in Figure 9 (b). Our goal is to push the box from one
configuration ((sx, sy, Œ∏)) to another. From , given (1) the pusher‚Äôs position (px, py) and the contact force (Fx, Fy) in the
slider frame; (2) the slider‚Äôs position (sx, sy) and angle Œ∏ in the world frame, the quasi-static dynamics of the slider can be
written as:
d
dtsx =
1
¬µ1mg ¬∑ (cos Œ∏Fx ‚àísin Œ∏Fy)
(A20)
d
dtsy =
1
¬µ1mg ¬∑ (sin Œ∏Fx + cos Œ∏Fy)
(A21)
d
dtŒ∏ =
1
cr ¬∑ ¬µ1mg ¬∑ (‚àípyFx + pxFy)
(A22)
where ¬µ1 is the friction coefficient between the slider and table. c ‚àà(0, 1) is the integration constant that depends on the
slider geometry. r is a characteristic distance, typically chosen as the max distance between a contact point and origin of slider
frame . Use the dimensionless trick:
Fx ‚Üê
1
¬µ1mg ¬∑ Fx, Fy ‚Üê
1
¬µ1mg ¬∑ Fy
(A23)
Discretize over the lie group:
sx,k = sx,k‚àí1 + ‚àÜt ¬∑ (rc,k‚àí1Fx,k‚àí1 ‚àírs,k‚àí1Fy,k‚àí1)
(A24)
sy,k = sy,k‚àí1 + ‚àÜt ¬∑ (rs,k‚àí1Fx,k‚àí1 + rc,k‚àí1Fy,k‚àí1)
(A25)
fs,k‚àí1 = ‚àÜt ¬∑ 1
cr ¬∑ (‚àípy,k‚àí1Fx,k‚àí1 + px,k‚àí1Fy,k‚àí1)
(A26)
Here, the lie-group constraints (A15) - (A18) are omitted for simplicity. Since when pusher has no contact with the slider,
slider remains still and pusher‚Äôs planning task is trivial, we only fucus on the time steps when pusher and slider have contact.
As illustrated in Figure 9 (b), we assign for modes Œªi‚Äôs (i = 1, 2, 3, 4 for box‚Äôs four sides):
Œªi(1 ‚àíŒªi) = 0, i = 1, 2, 3, 4
(A27)
4
X
i=1
Œª2
i = 1
(A28)
In each mode, the relationship between Fx, Fy, px, py is different. For example, in mode 1:
Œª1 ¬∑ (a2 ‚àíp2
x) ‚â•0
(A29)
Œª1 ¬∑ (py ‚àíb) = 0
(A30)
Œª1 ¬∑ (‚àíFy) ‚â•0
(A31)
where for modelling simplicity, we assume the pushing direction will always be normal to the contact surface. Similar contact
constraints can be assigned to mode 2 - 4. Simplify them:
(Œª1 + Œª3) ¬∑ (a2 ‚àíp2
x) + (Œª2 + Œª4) ¬∑ (b2 ‚àíp2
y) ‚â•0
(A32)
Œª1 ¬∑ (py ‚àíb) + Œª2 ¬∑ (px ‚àía) + Œª3 ¬∑ (py + b) + Œª4 ¬∑ (px + a) = 0
(A33)
(‚àíŒª1 + Œª3) ¬∑ Fy + (‚àíŒª2 + Œª4) ¬∑ Fx ‚â•0
(A34)
(Œª1 + Œª3) ¬∑ Fx + (Œª2 + Œª4) ¬∑ Fy = 0
(A35)
The loss function is in the same spirit as (A19). We omit it here.
3) Push T-block: Now we consider a more complicated pushing task: push a T-block, as illustrated in Figure 9 (c). Unlike
4 modes in the box setting, now we have 8 modes to assign. From , when ¬µ1 is uniformly distributed between the slider
and the table, the friction center coincides with the projection of the center of mass (CM) to the table. Thus, we set the origin
of the Slider frame to T-block‚Äôs CM for convenience. dc from Figure 9 (c) can be derived as:
dc = 3 √ó 1.5 + 4 √ó 3.5
3 + 4
= 37
14
(A36)
There are eight key points in the T-block:
x1 = ‚àí2l, x2 = ‚àí0.5l, x3 = 0.5l, x4 = 2l
(A37)
y1 = ‚àídcl, y2 = (3 ‚àídc)l, y3 = (4 ‚àídc)l
(A38)
Connect each mode with geometric and dynamical constraints:
Œª1 =‚áípy ‚àíy3 = 0, px ‚àíx1 ‚â•0, x4 ‚àípx ‚â•0, ‚àíFy ‚â•0, Fx = 0
(A39)
Œª2 =‚áípx ‚àíx4 = 0, py ‚àíy2 ‚â•0, y3 ‚àípy ‚â•0, ‚àíFx ‚â•0, Fy = 0
(A40)
Œª3 =‚áípy ‚àíy2 = 0, px ‚àíx3 ‚â•0, x4 ‚àípx ‚â•0, Fy ‚â•0, Fx = 0
(A41)
Œª4 =‚áípx ‚àíx3 = 0, py ‚àíy1 ‚â•0, y2 ‚àípy ‚â•0, ‚àíFx ‚â•0, Fy = 0
(A42)
Œª5 =‚áípy ‚àíy1 = 0, px ‚àíx2 ‚â•0, x3 ‚àípx ‚â•0, Fy ‚â•0, Fx = 0
(A43)
Œª6 =‚áípx ‚àíx2 = 0, py ‚àíy1 ‚â•0, y2 ‚àípy ‚â•0, Fx ‚â•0, Fy = 0
(A44)
Œª7 =‚áípy ‚àíy2 = 0, px ‚àíx1 ‚â•0, x2 ‚àípx ‚â•0, Fy ‚â•0, Fx = 0
(A45)
Œª8 =‚áípx ‚àíx1 = 0, py ‚àíy2 ‚â•0, y3 ‚àípy ‚â•0, Fx ‚â•0, Fy = 0
(A46)
Other things are the same as the Push Box case.
4) Push Box with a Tunnel: Everything is the same as Push Box setting, except that the box needs to avoid two circle
obstacles this time. To model the collision avoidance constraints, we approximate the box as a union of two circles, as shown
in Figure 9 (d). For each obstacle-slider circle pair, the non-collision constraint is:
(xo ‚àíxs)2 + (yo ‚àíys)2 ‚â•(ro + rs)2
(A47)
where (xo, yo, ro) (resp. (xs, ys, rs) ) represents center and radius of obstacle‚Äôs (resp. slider‚Äôs) center.
5) Planar Hand: The geometric and mechanical information of the Planar Hand system is illustrated in Figure 9 (e). The
goal is to rotate the circle disk 360‚ó¶with planar hand‚Äôs two finger tips, while minimize the translation of the disk‚Äôs center of
mass.
Kinematics of the fingers. For two fingers, we use position control. For example, for the right finger:
xr = Ld ¬∑ cos Œ∏rd + Lu ¬∑ cos Œ∏ru + H
2
(A48)
yr = Ld ¬∑ sin Œ∏rd + Lu ¬∑ sin Œ∏ru
(A49)
vx,r = ‚àíLd ¬∑ sin Œ∏rd ¬∑ ÀôŒ∏rd ‚àíLu ¬∑ sin Œ∏ru ¬∑ ÀôŒ∏ru
(A50)
vy,r = Ld ¬∑ cos Œ∏rd ¬∑ ÀôŒ∏rd + Lu ¬∑ cos Œ∏ru ¬∑ ÀôŒ∏ru
(A51)
where "r" and "l" represent "right" and "left" finger, while "u" and "d" represent "upper" and "down" link. Since
fs = sin( ÀôŒ∏ ¬∑ ‚àÜt) =‚áíÀôŒ∏ ‚âàfs
‚àÜt
(A52)
Then,
xr,k = Ld ¬∑ rc,rd,k + Lu ¬∑ rc,ru,k + H
2
(A53)
yr,k = Ld ¬∑ rs,rd,k + Lu ¬∑ rs,ru,k
(A54)
vx,r,k = ‚àíLd
‚àÜt ¬∑ rs,rd,k ¬∑ fs,rd,k ‚àíLu
‚àÜt ¬∑ rs,ru,k ¬∑ fs,ru,k
(A55)
vy,r,k = Ld
‚àÜt ¬∑ rc,rd,k ¬∑ fs,rd,k + Lu
‚àÜt ¬∑ rc,ru,k ¬∑ fs,ru,k
(A56)
rc,rd,k+1 = rc,rd,k ¬∑ fc,rd,k ‚àírs,rd,k ¬∑ fs,rd,k
(A57)
rs,rd,k+1 = rc,rd,k ¬∑ fs,rd,k + rs,rd,k ¬∑ fc,rd,k
(A58)
rc,ru,k+1 = rc,ru,k ¬∑ fc,ru,k ‚àírs,ru,k ¬∑ fs,ru,k
(A59)
rs,ru,k+1 = rc,ru,k ¬∑ fs,ru,k + rs,ru,k ¬∑ fc,ru,k
(A60)
Self collision avoidance. For each finger, there are two types of self collisions: (1) the first circle with the ground; (2) the
second and the third circle. For the first type:
Œ∏ld ‚â•arcsin(
r
l + r), œÄ ‚àíŒ∏ld ‚â•arcsin(
r
l + r)
(A61)
Œ∏rd ‚â•arcsin(
r
l + r), œÄ ‚àíŒ∏rd ‚â•arcsin(
r
l + r)
(A62)
For the second type:
œÄ ‚àíŒ∏ld + Œ∏lu ‚â•2 ¬∑ arcsin(
r
l + r)
(A63)
2œÄ ‚àí(œÄ ‚àíŒ∏rd + Œ∏ru) ‚â•2 ¬∑ arcsin(
r
l + r)
(A64)
Also, like a human finger, we assume the upper link won‚Äôt "turn outward":
Œ∏ld ‚àíŒ∏lu ‚â•0
(A65)
Œ∏ru ‚àíŒ∏rd ‚â•0
(A66)
Now denote Œ∏0 as arcsin( r
l+r). Writing the constraints as polynomials:
rs,ld,k ‚â•sin Œ∏0
(A67)
rs,rd,k ‚â•sin Œ∏0
(A68)
and
sin(Œ∏ld,k ‚àíŒ∏lu,k) = rs,ld,k ¬∑ rc,lu,k ‚àírc,ld,k ¬∑ rs,lu,k ‚â•0
(A69)
cos(Œ∏ld,k ‚àíŒ∏lu,k) = rc,ld,k ¬∑ rc,lu,k + rs,ld,k ¬∑ rs,lu,k ‚â•‚àícos(2Œ∏0)
(A70)
sin(Œ∏ru,k ‚àíŒ∏rd,k) = rs,ru,k ¬∑ rc,rd,k ‚àírc,ru,k ¬∑ rs,rd,k ‚â•0
(A71)
cos(Œ∏ru,k ‚àíŒ∏rd,k) = rc,ru,k ¬∑ rc,rd,k + rs,ru,k ¬∑ rs,rd,k ‚â•‚àícos(2Œ∏0)
(A72)
Contact model. Now we deal with the contact between the fingers and the disk. Without loss of generality, we consider
the right finger. Denote dr as:
d2
r = (xr ‚àíx)2 + (yr ‚àíy)2
(A73)
dr ‚â•R + r
(A74)
where (x, y) is the position of the disk‚Äôs center. When contact happens, dr = R + r. In this case, denote (vx, vy, w) as the
translational and angular velocity of the disk, (Œªt,r, Œªn,r) as the tangential and normal force exerted on the disk by the tip
of the finger, and vrel,r as the relative tangential velocity of finger‚Äôs tip compared to the disk. The physical quantities are
illustrated in Figure 9 (e)‚Äôs upper right position. Denote the angle Œ∑r as:
cos Œ∑r = xr ‚àíx
dr
(A75)
sin Œ∑r = yr ‚àíy
dr
(A76)
Then,
vrel,r ‚âà‚àívx,r ¬∑ sin Œ∑r + vy,r ¬∑ cos Œ∑r
‚àí(‚àívx ¬∑ sin Œ∑r + vy ¬∑ cos Œ∑r + œâR)
(A77)
Here we do one approximation for finger tip‚Äôs tangential velocity, by ignoring the tip‚Äôs size. One thing we should notice is,
Œªn will always point inside the disk:
‚àíŒªn,r ‚â•0
(A78)
By the Coulomb‚Äôs law:
Œªt,r
Ô£±
Ô£¥
Ô£≤
Ô£¥
Ô£≥
= ¬µ ¬∑ (‚àíŒªn,r), vrel,r > 0
= ‚àí¬µ ¬∑ (‚àíŒªn,r), vrel,r < 0
‚àà[‚àí¬µ ¬∑ (‚àíŒªn,r), ¬µ ¬∑ (‚àíŒªn,r)], vrel,r = 0
(A79)
Unlike  who introduced two auxiliary variables to app:pdress the above model as nine quadratic polynomials, we advocate
for a more concise representation:
¬µ2 ¬∑ Œª2
n,r ‚àíŒª2
t,r ‚â•0
(A80)
vrel,r ¬∑ (¬µ2 ¬∑ Œª2
n,r ‚àíŒª2
t,r) = 0
(A81)
vrel,r ¬∑ Œªt,r ‚â•0
(A82)
Combine everything together:
d2
r,k = (xr,k ‚àíxk)2 + (yr,k ‚àíyk)2
(A83)
dr,k ‚â•R + r
(A84)
vrel,r,k = ‚àí(vx,r,k ‚àívx,k) ¬∑ yr,k ‚àíyk
R + r
+ (vy,r,k ‚àívy,k) ¬∑ xr,k ‚àíxk
R + r
‚àíR ¬∑ fs,k
‚àÜt
(A85)
(dr,k ‚àíR ‚àír) ¬∑ Œªn,r,k = 0
(A86)
‚àíŒªn,r,k ‚â•0
(A87)
¬µ2 ¬∑ Œª2
n,r,k ‚àíŒª2
t,r,k ‚â•0
(A88)
vrel,r,k ¬∑ (¬µ2 ¬∑ Œª2
n,r,k ‚àíŒª2
t,r,k) = 0
(A89)
vrel,r,k ¬∑ Œªt,r,k ‚â•0
(A90)
Dynamics of disk. Consider the quasi-static dynamics similar to (A20):
d
dtx = Œªn,r ¬∑ cos Œ∑r ‚àíŒªt,r ¬∑ sin Œ∑r + Œªn,l ¬∑ cos Œ∑l ‚àíŒªt,r ¬∑ sin Œ∑l
(A91)
d
dty = Œªn,r ¬∑ sin Œ∑r + Œªt,r ¬∑ cos Œ∑r + Œªn,l ¬∑ sin Œ∑l + Œªt,r ¬∑ cos Œ∑l
(A92)
d
dtŒ± =
1
c ¬∑ R ¬∑ (Œªt,r + Œªt,l)
(A93)
Write them as polynomials:
1
‚àÜt(xk+1 ‚àíxk) = Œªn,r,k ¬∑ xr,k ‚àíxk
R + r
‚àíŒªt,r,k ¬∑ yr,k ‚àíyk
R + r
+ Œªn,l,k ¬∑ xl,k ‚àíxk
R + r
‚àíŒªt,l,k ¬∑ yl,k ‚àíyk
R + r
(A94)
1
‚àÜt(yk+1 ‚àíyk) = Œªn,r,k ¬∑ yr,k ‚àíyk
R + r
+ Œªt,r,k ¬∑ xr,k ‚àíxk
R + r
+ Œªn,l,k ¬∑ yl,k ‚àíyk
R + r
+ Œªt,l,k ¬∑ xl,k ‚àíxk
R + r
(A95)
fs,k = ‚àÜt
c ¬∑ R ¬∑ (Œªt,r,k + Œªt,l,k)
(A96)
rc,k+1 = rc,k ¬∑ fc,k ‚àírs,k ¬∑ fs,k
(A97)
rs,k+1 = rc,k ¬∑ fs,k + rs,k ¬∑ fc,k
(A98)
f 2
s,k + f 2
c,k = 1
(A99)
Collision avoidance. Consider the right finger. Since the finger tip has already been considered in the contact model, we
only need to consider collision avoidance between the object and the remaining three circles attached to the finger. The three
circles‚Äô positions are:

(l + r) cos Œ∏rd + H
2 , (l + r) sin Œ∏rd

(A100)

(2l + 3r) cos Œ∏rd + H
2 , (2l + 3r) sin Œ∏rd

(A101)

Ld cos Œ∏rd + (l + r) cos Œ∏ru + H
2 , Ld sin Œ∏rd + (l + r) sin Œ∏ru

(A102)
Therefore, the constraints are:

(l + r) ¬∑ rc,rd,k ‚àíxk + H
2
2
+ ((l + r) ¬∑ rs,rd,k ‚àíyk)2 ‚â•(R + r)2
(A103)

(2l + 3r) ¬∑ rc,rd,k ‚àíxk + H
2
2
+ ((2l + 3r) ¬∑ rs,rd,k ‚àíyk)2 ‚â•(R + r)2
(A104)

Ld ¬∑ rc,rd,k + (l + r) ¬∑ rc,ru,k ‚àíxk + H
2
2
+ (Ld ¬∑ rs,rd,k + (l + r) ¬∑ rs,ru,k ‚àíyk)2 ‚â•(R + r)2
(A105)
D. Self-Defined Variable Cliques for Planar hand
The self-defined variable cliques for PLanar Hand are defined as:
{xk, yk, rc,k, rs,k, rc,ld,k, rs,ld,k, rc,lu,k, rs,lu,k, rc,rd,k, rs,rd,k, rc,ru,k, rs,ru,k}
(A106a)
{xk, yk, rc,ld,k, rs,ld,k, rc,lu,k, rs,lu,k, xl,k, yl,k, dl,k}
(A106b)
{rc,ld,k, rs,ld,k, rc,lu,k, rs,lu,k, xl,k, yl,k}
(A106c)
{rc,ld,k, rs,ld,k, fc,ld,k, fs,ld,k, rc,lu,k, rs,lu,k, fc,lu,k, fs,lu,k, vx,l,k, vy,l,k}
(A106d)
{xk, yk, rc,rd,k, rs,rd,k, rc,ru,k, rs,ru,k, xr,k, yr,k, dr,k}
(A106e)
{rc,k, rc,k+1, rs,k, rs,k+1, fc,k, fs,k}
(A106f)
{rc,rd,k, rs,rd,k, rc,ru,k, rs,ru,k, xr,k, yr,k}
(A106g)
{rc,rd,k, rs,rd,k, fc,rd,k, fs,rd,k, rc,ru,k, rs,ru,k, fc,ru,k, fs,ru,k, vx,r,k, vy,r,k}
(A106h)
{xk, xk+1, yk, yk+1, fc,k, fs,k, xl,k, yl,k, vx,l,k, vy,l,k, dl,k, vrel,l,k, Œªn,l,k, Œªt,l,k}
(A106i)
{rc,ld,k, rc,ld,k+1, rs,ld,k, rs,ld,k+1, fc,ld,k, fs,ld,k, rc,lu,k, rc,lu,k+1, rs,lu,k, rs,lu,k+1, fc,lu,k, fs,lu,k}
(A106j)
{xk, xk+1, yk, yk+1, fc,k, fs,k, xl,k, yl,k, xr,k, yr,k, Œªn,l,k, Œªt,l,k, Œªn,r,k, Œªt,r,k}
(A106k)
{xk, xk+1, yk, yk+1, fc,k, fs,k, xr,k, yr,k, vx,r,k, vy,r,k, dr,k, vrel,r,k, Œªn,r,k, Œªt,r,k}
(A106l)
{rc,rd,k, rc,rd,k+1, rs,rd,k, rs,rd,k+1, fc,rd,k, fs,rd,k, rc,ru,k, rc,ru,k+1, rs,ru,k, rs,ru,k+1, fc,ru,k, fs,ru,k}
(A106m)
{xk+1, yk+1, rc,ld,k+1, rs,ld,k+1, rc,lu,k+1, rs,lu,k+1, rc,rd,k+1, rs,rd,k+1, rc,ru,k+1, rs,ru,k+1}
(A106n)
